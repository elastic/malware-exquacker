import base64
import importlib.resources
import json
import logging
import pathlib
import zlib
from typing import Any, Dict

import pytest
from elasticsearch import Elasticsearch
from malduck import procmem, procmempe
from malduck.extractor import ExtractManager, ExtractorModules
from scalpl import Cut

from elastic.malware_config_extractor.modules.utils import Config

logger = logging.getLogger(__name__)


MODULE_NAME: str = "elastic.malware_config_extractor.modules.cobalt_strike"

# Extractor modules wants the directory of modules. It might be possible (and better)
# to isolate the cobalt_strike module without loading the whole dir
with importlib.resources.path(MODULE_NAME, "cobalt_strike.yar") as f:
    MODULE_PATH: str = str(f.parent.parent)


def test_from_bin_file(datadir: pathlib.Path):
    """unit test for the module"""
    extractor_modules = ExtractorModules(modules_path=MODULE_PATH)
    assert "CobaltStrike" in [
        extractor.__name__ for extractor in extractor_modules.extractors
    ]

    extract_manager = ExtractManager(extractor_modules)  # handles multiple modules

    with procmem.from_file(str(datadir / "beacon-sample.bin")) as p:
        extract_manager.push_procmem(p, True)

    result: list[Config] = []
    if extract_manager.config:
        result = extract_manager.config

    assert len(result) == 1
    assert result[0].get("family", None) == "cobalt_strike"
    assert "cobalt_strike" in result[0]
    assert isinstance(result[0]["cobalt_strike"], dict)


def test_from_telemetry_file(datadir: pathlib.Path):
    """Uses a json of the telemetry query response, rather than querying elasticsearch each time"""
    with open(datadir / "cobalt_strike_telemetry_result.json", "r") as f:
        raw = f.read()

    result = Cut(json.loads(raw))
    cobalt_strike_bytes = result[
        "hits.hits[0]._source.process.Ext.memory_region.bytes_compressed"
    ]
    payload = zlib.decompress(base64.b64decode(cobalt_strike_bytes))
    addr = result["hits.hits[0]._source.process.Ext.memory_region.bytes_address"]

    extractor_modules = ExtractorModules(modules_path=MODULE_PATH)
    with procmempe(payload, base=addr) as p:
        result = p.extract(extractor_modules)

    assert len(result) == 1
    assert result[0].get("family", None) == "cobalt_strike"
    assert "cobalt_strike" in result[0]
    assert isinstance(result[0]["cobalt_strike"], dict)


@pytest.fixture
def search_response(datadir: pathlib.Path):
    with open(datadir / "test-search-response-cobaltstrike.json", "rt") as f:
        _response: str = f.read()
        yield _response


def test_from_search_data(es_client: Elasticsearch):
    """
    integration test, pulls 3 known cobalt strike samples from a mock Elasticsearch
    client
    """

    # This query is gen
    query = {
        "size": 3,
        "query": {
            "bool": {
                "should": [
                    {"match": {"event.category": "malware"}},
                    {"match": {"event.category": "intrusion_detection"}},
                ],
                "must": [
                    {
                        "match": {
                            "process.Ext.memory_region.bytes_compressed_present": "true"
                        }
                    },
                    {"match": {"rule.name": "Windows.Trojan.CobaltStrike"}},
                ],
                "minimum_should_match": 1,
            },
        },
    }

    # This is a mock object with a predetermined response of 3 hits.
    result = Cut(es_client.search(body=query, index="logs-alert-*"))

    print(f"Number of hits: {len(result['hits']['hits'])}")
    cobalt_strike_bytes = result[
        "hits.hits[0]._source.process.Ext.memory_region.bytes_compressed"
    ]
    payload = zlib.decompress(base64.b64decode(cobalt_strike_bytes))
    addr = result["hits"]["hits"][0]["_source"]["process"]["Ext"]["memory_region"][
        "bytes_address"
    ]

    extractor_modules = ExtractorModules(modules_path=MODULE_PATH)

    results: list[Dict[str, Any]] = []
    # TODO: The current items currently has one payload that is detected as a PE
    # and 2 that are not. Since the rule relies on procmempe, need to figure out
    # if we can clean that up
    for item in result["hits.hits"]:
        extract_manager = ExtractManager(extractor_modules)
        item = Cut(item)
        compressed_bytes = item["_source.process.Ext.memory_region.bytes_compressed"]
        payload = zlib.decompress(base64.b64decode(compressed_bytes))
        addr = item["_source.process.Ext.memory_region.bytes_address"]

        with procmem(payload, addr) as p:
            extract_manager.push_procmem(p, rip_binaries=True)

        if extract_manager.config:
            results.append(extract_manager.config[0])

        # Might be a better way, for now, create a clean extract_manager per sample
        del extract_manager

    assert len(results) == 1
    assert results[0].get("family", None) == "cobalt_strike"
    assert "cobalt_strike" in results[0]
    assert isinstance(results[0]["cobalt_strike"], dict)


@pytest.mark.skip(reason="no way of currently testing this")
def test_integration_docker_search():
    """
    Looking to make this an optional test where a local Elasticsearch container is setup with sample
    logs that could provide a more robust test suite.
    """
    pass
