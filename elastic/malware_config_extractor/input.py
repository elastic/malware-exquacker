from logging import getLogger
from queue import Queue
from threading import Thread

from elasticsearch import Elasticsearch
from elasticsearch_dsl import Search, connections
from scalpl import Cut

from .elastic_dsl import get_input_search
from .utils import connect_elasticsearch

logger = getLogger(__name__)


class AlertSampleESInput(Thread):
    def __init__(self, config: Cut, event_queue: Queue, since: str = None, before: str = None) -> None:
        super().__init__()
        self.es_client: Elasticsearch = None
        self.config: Cut = config
        self.since: str = since
        self.before: str = before
        logger.debug(f"Parsed input config: {self.config}")

    def _setup_io(self):
        logger.info("Setting up input connection")

        if self.config["enabled"] is True:
            logger.info("Connecting to Elasticsearch for input")
            self.input_es = connect_elasticsearch(self.config)

            if self.input_es:
                logger.info("Successfully connected to Elasticsearch for input")
                connections.add_connection("input", self.input_es)

            _info = self.input_es.info()
            self.source_info: dict[str, str] = {
                "_cluster_info": {
                    "cluster_name": _info["cluster_name"],
                    "cluster_uuid": _info["cluster_uuid"],
                }
            }
        else:
            self.input_es = None
            logger.error("No supported input is enabled. Please configure the input.")

    def _extract(self):
        logger.info("Retreiving latest results")

        _results = self.search.execute()
        logger.info(f"Retrieved {_results.hits.total.value} hits")

    def run(self):
        self._setup_io()
        self.search: Search = get_input_search(self.config["index"])

        _filter: dict = {"@timestamp": {}}
        if self.since is not None:
            _filter["@timestamp"] |= {"gte": self.since}
        if self.before is not None:
            _filter["@timestamp"] |= {"lt": self.before}

        logger.debug(f"Date filter: {_filter}")
        if _filter["@timestamp"] != {}:
            self.search = self.search.filter("range", **_filter)

        self._extract()
