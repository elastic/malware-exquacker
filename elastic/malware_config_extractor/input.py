import sys

if sys.version_info < (3, 10):
    from __future__ import annotations

import time
from logging import getLogger
from typing import Any, Iterable, Optional

from elasticsearch import Elasticsearch
from elasticsearch_dsl import Search, connections
from scalpl import Cut

from elastic.malware_config_extractor.elastic_dsl import get_input_search
from elastic.malware_config_extractor.process import POISON_PILL, InputProcess
from elastic.malware_config_extractor.utils import connect_elasticsearch

logger = getLogger(__name__)


class AlertSampleESInput(InputProcess):
    def __init__(
        self,
        config: Cut,
        background: bool,
        poll_interval: int,
        since: Optional[str] = None,
        before: Optional[str] = None,
        *args,
        **kwargs,
    ) -> None:
        super().__init__(*args, **kwargs)

        self.es_client: Elasticsearch | None
        self.config: Cut = config
        self.background: bool = background
        self.poll_interval: int = poll_interval
        self.since: Optional[str] = since
        self.before: Optional[str] = before

    def _setup_io(self):
        logger.info("Setting up input connection")

        if self.config["enabled"] is True:
            logger.info("Connecting to Elasticsearch for input")
            self.es_client = connect_elasticsearch(dict(self.config))

            if self.es_client:
                logger.info("Successfully connected to Elasticsearch for input")
                connections.add_connection("input", self.es_client)

            _info = self.es_client.info()
            self.source_info: dict[str, str | dict[str, str]] = {
                "_cluster_info": {
                    "cluster_name": _info["cluster_name"],
                    "cluster_uuid": _info["cluster_uuid"],
                }
            }
        else:
            self.es_client = None
            logger.error("No supported input is enabled. Please configure the input.")

    def extract(self) -> Iterable[dict[str, Any]]:

        while True:

            if self.shutdown.is_set():
                break

            _count: int = 0
            logger.info("Retreiving latest results")

            for hit in self.search.scan():
                _count += 1
                logger.debug(f"Extracting document #{_count}")

                doc: dict = {"_source": hit.to_dict()} | hit.meta.to_dict() | self.source_info  # type: ignore
                yield doc

            logger.info(f"Retrieved {_count} hits")
            # If we're not running as a daemon, stop after one run
            # otherwise, wait for the poll_interval number of minutes
            if not self.background:
                break
            else:
                time.sleep(self.poll_interval * 60.0)

    def run(self):
        super().run()

        logger.info("Entering run()")

        self._setup_io()
        self.search: Search = get_input_search(self.config["index"])

        _filter: dict = {"@timestamp": {}}
        if self.since is not None:
            _filter["@timestamp"] |= {"gte": self.since}
        if self.before is not None:
            _filter["@timestamp"] |= {"lt": self.before}

        logger.debug(f"Date filter: {_filter}")
        if _filter["@timestamp"] != {}:
            self.search = self.search.filter("range", **_filter)

        for item in self.extract():
            logger.debug("Writing document to queue")
            self.outq.put(item)

        # Signal the end of events
        self.outq.put(POISON_PILL)

        # Cleanup
        if self.es_client is not None:
            logger.debug("Closing Elasticsearch input client.")
            self.es_client.close()
