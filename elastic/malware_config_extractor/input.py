from logging import getLogger
from queue import Queue

from elasticsearch import Elasticsearch
from elasticsearch_dsl import Search, connections
from scalpl import Cut

from .elastic_dsl import get_input_search
from .thread import BaseThread
from .utils import connect_elasticsearch

logger = getLogger(__name__)


class AlertSampleESInput(BaseThread):
    def __init__(
        self,
        config: Cut,
        background: bool,
        poll_interval: int,
        outq: Queue,
        since: str = None,
        before: str = None,
        **kwargs,
    ) -> None:
        super().__init__(**kwargs)
        self.es_client: Elasticsearch = None
        self.config: Cut = config
        self.background: bool = background
        self.poll_interval: int = poll_interval
        self.since: str = since
        self.before: str = before
        logger.debug(f"Parsed input config: {self.config}")

    def _setup_io(self):
        logger.info("Setting up input connection")

        if self.config["enabled"] is True:
            logger.info("Connecting to Elasticsearch for input")
            self.input_es = connect_elasticsearch(self.config)

            if self.input_es:
                logger.info("Successfully connected to Elasticsearch for input")
                connections.add_connection("input", self.input_es)

            _info = self.input_es.info()
            self.source_info: dict[str, str] = {
                "_cluster_info": {
                    "cluster_name": _info["cluster_name"],
                    "cluster_uuid": _info["cluster_uuid"],
                }
            }
        else:
            self.input_es = None
            logger.error("No supported input is enabled. Please configure the input.")

    def _extract(self):
        if self.done is True:
            return

        while True:

            logger.info("Retreiving latest results")
            _results = self.search.execute()

            logger.info(f"Retrieved {_results.hits.total.value} hits")

            # If we're not running as a daemon, stop after one run
            # otherwise, wait for the poll_interval number of minutes
            # if `done` becomes true during this wait, return immediately
            if not self.background or self.done.wait(self.poll_interval * 60.0) is True:
                break

    def run(self):

        self._setup_io()
        self.search: Search = get_input_search(self.config["index"])

        _filter: dict = {"@timestamp": {}}
        if self.since is not None:
            _filter["@timestamp"] |= {"gte": self.since}
        if self.before is not None:
            _filter["@timestamp"] |= {"lt": self.before}

        logger.debug(f"Date filter: {_filter}")
        if _filter["@timestamp"] != {}:
            self.search = self.search.filter("range", **_filter)

        self._extract()

        # Cleanup
        self.es_client.close()
