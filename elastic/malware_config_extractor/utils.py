from logging import getLogger
from queue import Empty, Queue
from typing import Any, Dict, Generator

from elasticsearch import Elasticsearch
from scalpl import Cut

logger = getLogger(__name__)


def dedot_keys(d: Dict) -> Dict:
    _c = Cut({})
    for k, v in d.items():
        _c.setdefault(k, v)

    return dict(_c)


def merge_dict(
    a: Dict, b: Dict, path: list[str] = None, overwrite: bool = False
) -> Dict:
    """merges b into a

    Note: you can simplify this quite a bit since python knows how to do this for you with the double-splat notation,
    z = {**x, **y}

    it won't overwrite if the keys are different.

    There's no need for recursion at all, but you can still add some other logic if you want to check
    if the value already exists and choose not to overwrite it.

    """
    if path is None:
        path = []
    for key in b:
        if key in a:
            if isinstance(a[key], dict) and isinstance(b[key], dict):
                merge_dict(a[key], b[key], path + [str(key)], overwrite)
            elif a[key] == b[key]:
                pass  # same leaf value
            elif overwrite is True:
                a[key] = b[key]
            else:
                raise Exception("Conflict at %s" % ".".join(path + [str(key)]))
        else:
            a[key] = b[key]
    return a


def connect_elasticsearch(es_config: dict[str, str] = {}) -> Elasticsearch:
    _es: Elasticsearch = None
    _apikey: tuple(str) = None
    _httpauth: tuple(str) = None

    es_config = Cut(es_config)

    if es_config.get("enabled", False):
        if es_config.get("cloud.auth", None):
            _httpauth = tuple(es_config.get("cloud.auth").split(":"))
        elif es_config.get("username", None) and es_config.get("password", None):
            _httpauth = (
                es_config.get("username"),
                es_config.get("password"),
            )

        if es_config.get("api_key", None):
            _apikey = tuple(es_config.get("api_key").split(":"))

        if _httpauth is not None and _apikey is not None:
            logger.critical(
                "Either username/password auth or api_key auth should be used for elasticsearch, not both."
            )
            raise ValueError

        if es_config.get("cloud.id", None):
            logger.debug(
                f"Connecting to Elasticsearch using cloud.id {es_config.get('cloud.id')}"
            )
            _es = Elasticsearch(
                cloud_id=es_config.get("cloud.id"),
                verify_certs=es_config.get("ssl_verify", True),
                http_auth=_httpauth,
                api_key=_apikey,
                timeout=30,
                max_retries=10,
                retry_on_timeout=True,
            )
        else:
            logger.debug(
                f"Connecting to Elasticsearch using hosts: {es_config.get('hosts', ['127.0.0.1:9200'])}"
            )
            _es = Elasticsearch(
                hosts=es_config.get("hosts", ["127.0.0.1:9200"]),
                verify_certs=es_config.get("ssl_verify", True),
                http_auth=_httpauth,
                api_key=_apikey,
                timeout=30,
                max_retries=10,
                retry_on_timeout=True,
            )

        if _es.ping():
            logger.info("Successfully connected to Elasticsearch")
        else:
            raise RuntimeError("Something went wrong with connecting to Elasticsearch")
    else:
        logger.info("Elasticsearch is marked disabled. Skipping.")

    return _es


def consume_queue(q: Queue) -> Generator[Any, None, None]:
    while True:
        try:
            item = q.get_nowait()
            yield item
            q.task_done()
        except Empty:
            yield None
        except GeneratorExit:
            q.task_done()
            break
