import os
import select
import threading
from typing import Any, Mapping, Union


class WaitableEvent:
    """
    Provides an abstract object that can be used to resume select loops with
    indefinite waits from another thread or process. This mimics the standard
    threading.Event interface.

    ref: https://lat.sk/2015/02/multiple-event-waiting-python-3/
    """

    def __init__(self):
        self._read_fd, self._write_fd = os.pipe()

    def wait(self, timeout=None):
        rfds, wfds, efds = select.select([self._read_fd], [], [], timeout)
        return self._read_fd in rfds

    def is_set(self):
        return self.wait(0)

    def clear(self):
        if self.is_set():
            os.read(self._read_fd, 1)

    def set(self):
        if not self.is_set():
            os.write(self._write_fd, b"1")

    def fileno(self):
        """
        Return the FD number of the read side of the pipe, allows this object to
        be used with select.select().
        """
        return self._read_fd

    def __bool__(self) -> bool:
        return self.is_set()

    def __del__(self):
        os.close(self._read_fd)
        os.close(self._write_fd)


class BaseThread(threading.Thread):
    def __init__(
        self,
        **kwargs: Union[Mapping[str, Any], None],
    ) -> None:
        super().__init__(**kwargs)
        self.halt: threading.Event = threading.Event()
        self.done: WaitableEvent = WaitableEvent()
        self.quit_when_idle: WaitableEvent = WaitableEvent()
        self._exc_info: threading.ExceptHookArgs = None

    def _run(self):
        raise NotImplementedError("Thread class needs to implement _run()")

    def run(self):
        self._exc = None
        try:
            self._run()
        except BaseException as e:
            self._exc = e
        finally:
            self.done.set()

    def join(self):
        super().join()

        if self._exc_info:
            raise self._exc_info.exc_type(
                *self._exc_info.exc_value.args
            ).with_traceback(self._exc_info.exc_traceback)


def custom_hook(args: threading.ExceptHookArgs):
    """This hook will propagate the failure to the calling thread"""
    if isinstance(args.thread, BaseThread):
        args.thread._exc_info = args
        args.thread.done.set()


# set the exception hook
threading.excepthook = custom_hook
