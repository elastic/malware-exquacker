import base64
import zlib
from logging import getLogger
from queue import Queue
from typing import Any, Dict, Generator, Iterable

from malduck.extractor import ExtractManager, ExtractorModules
from malduck.procmem import ProcessMemory
from scalpl import Cut

from elastic.malware_config_extractor.thread import BaseThread
from elastic.malware_config_extractor.utils import consume_queue

logger = getLogger(__name__)


class MalduckTransform(BaseThread):
    def __init__(self, config: Cut, taskq: Queue, outq: Queue, **kwargs) -> None:
        super().__init__(**kwargs)

        self.config: Cut = config
        self.modules = None
        self.samples = None
        self.taskq = taskq
        self.outq = outq

        logger.debug(f"Parsed input config: {self.config}")

    def _setup_modules(self):
        # Set up the module paths.
        if self.config["modules"]:
            logger.info("Getting os path of malduck modules...")
            self.modules = (
                self.config["modules"]
                if self.config["modules"]
                else logger.error("Please specify Malduck module path.")
            )

        self.extractor_modules = ExtractorModules(modules_path=self.modules)

    def process_configs(self, extract_manager):
        if extract_manager.config:
            for config in extract_manager.config:
                logger.debug(config)
                family = config["family"]
                logger.info(f"[+] Ripped '{family}' configuration:")
                logger.debug(config)
                yield config

    def transform(self) -> Iterable[dict[str, Any]]:

        # self.done is a threading Event (see .thread.WaitableEvent)
        # that is False unless an unhandled exception occurs or the
        # main thread calls done.set() to signal that it's time to quit

        while not self.done and not self.quit_when_idle:
            _count: int = 0
            _q: Generator[Any] = consume_queue(self.taskq)

            for doc in _q:
                if self.done:
                    break
                if doc is None:
                    if self.quit_when_idle:
                        break
                    continue

                # logger.debug(f"Processing {doc}")

                _doc = Cut(doc)
                _bytes_compressed = _doc[
                    "_source.process.Ext.memory_region.bytes_compressed"
                ]
                logger.debug("Decompressing")
                _payload_bytes = zlib.decompress(base64.b64decode(_bytes_compressed))

                self.extract_manager = ExtractManager(self.extractor_modules)

                if not self.extract_manager.extractors:
                    logger.exception(
                        f"[!] No extractor modules found under '{self.modules}'!"
                    )
                self.extract_manager.push_procmem(
                    ProcessMemory(_payload_bytes), rip_binaries=True
                )

                for item in self.generate_output_doc(_doc, self.extract_manager):
                    yield item
                    _count += 1

            _q.close()
            logger.info(f"Transform, generated {_count} documents in this batch")

    def generate_output_doc(self, _doc, extract_manager) -> Iterable[Dict[str, Any]]:
        if extract_manager.config:
            for extracted_config in extract_manager.config:
                out_doc: dict[str, Any] = {}
                out_doc["@timestamp"] = _doc["_source.@timestamp"]
                out_doc["_id"] = _doc["id"]
                out_doc["agent"] = {"id": _doc["_source.agent.id"]}
                out_doc["event"] = {
                    "kind": "event",
                    "category": "malware",
                    "type": "info",
                }
                out_doc["event"]["xref"] = {
                    "cluster_name": _doc["_cluster_info.cluster_name"],
                    "cluster_uuid": _doc["_cluster_info.cluster_uuid"],
                    "index": _doc["index"],
                    "id": _doc["id"],
                }

                out_doc["process"] = {"args": _doc["_source.process.args"]}
                out_doc["threat"] = {"software": {"config": extracted_config}}

                if _doc.get("_source.file"):
                    _file = {}
                    if _doc.get("_source.file.hash"):
                        _file["hash"] = _doc["_source.file.hash"]
                    if _doc.get("_source.file.name"):
                        _file["name"] = _doc["_source.file.name"]
                    if _doc.get("_source.file.size"):
                        _file["size"] = _doc["_source.file.size"]
                    if _file:
                        out_doc["file"] = _file

                if _doc.get("_source.rule"):
                    out_doc["rule"] = _doc["_source.rule"]

                # TODO Add "related" field.
                out_doc["tags"] = ["malware", extracted_config["family"]]
                yield out_doc

                break

    def run(self) -> None:
        self._setup_modules()

        for item in self.transform():
            self.outq.put(item)

        logger.debug("Waiting to clear the output queue")
        # Wait for the queue to complete before closing this thread
        while self.outq.unfinished_tasks:
            pass

        logger.debug("Shutting down transform")
