import base64
from queue import Empty
import zlib
from logging import getLogger
from multiprocessing import JoinableQueue
from typing import Any, Dict, Generator, Iterable

from malduck.extractor import ExtractManager, ExtractorModules
from malduck.procmem import ProcessMemory
from scalpl import Cut

from elastic.malware_config_extractor.process import POISON_PILL, FilterProcess
from elastic.malware_config_extractor.utils import consume_queue

logger = getLogger(__name__)


class MalduckTransform(FilterProcess):
    def __init__(self, config: Cut, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.config: Cut = config
        self.modules = None
        self.samples = None

    def _setup_modules(self):
        # Set up the module paths.
        if self.config["modules"]:
            logger.info("Getting os path of malduck modules...")
            self.modules = (
                self.config["modules"]
                if self.config["modules"]
                else logger.error("Please specify Malduck module path.")
            )

        self.extractor_modules = ExtractorModules(modules_path=self.modules)

    def process_configs(self, extract_manager):
        if extract_manager.config:
            for config in extract_manager.config:
                logger.debug(config)
                family = config["family"]
                logger.info(f"[+] Ripped '{family}' configuration:")
                logger.debug(config)
                yield config

    def transform(self) -> Iterable[dict[str, Any]]:

        # self.done is a multiprocessing Event (see .thread.WaitableEvent)
        # that is False unless an unhandled exception occurs or the
        # main thread calls done.set() to signal that it's time to quit

        _count: int = 0
        while True:

            if self.shutdown.is_set():
                break

            try:
                doc = self.inq.get_nowait()
            except Empty:
                continue

            if doc is POISON_PILL:
                self.inq.put(POISON_PILL)
                break
            else:
                _doc = Cut(doc)
                _bytes_compressed = _doc[
                    "_source.process.Ext.memory_region.bytes_compressed"
                ]
                logger.debug("Decompressing")
                _payload_bytes = zlib.decompress(base64.b64decode(_bytes_compressed))

                self.extract_manager = ExtractManager(self.extractor_modules)

                if not self.extract_manager.extractors:
                    logger.exception(
                        f"[!] No extractor modules found under '{self.modules}'!"
                    )
                self.extract_manager.push_procmem(
                    ProcessMemory(_payload_bytes), rip_binaries=True
                )

                for item in self.generate_output_doc(_doc, self.extract_manager):
                    yield item
                    _count += 1

        logger.info(f"Transform, generated {_count} documents in this batch")

    def generate_output_doc(self, _doc, extract_manager) -> Iterable[Dict[str, Any]]:
        if extract_manager.config:
            for extracted_config in extract_manager.config:
                out_doc: dict[str, Any] = {}
                out_doc["@timestamp"] = _doc["_source.@timestamp"]
                out_doc["_id"] = _doc["id"]
                out_doc["agent"] = {"id": _doc["_source.agent.id"]}
                out_doc["event"] = {
                    "kind": "event",
                    "category": "malware",
                    "type": "info",
                }
                out_doc["event"]["xref"] = {  # type: ignore
                    "cluster_name": _doc["_cluster_info.cluster_name"],
                    "cluster_uuid": _doc["_cluster_info.cluster_uuid"],
                    "index": _doc["index"],
                    "id": _doc["id"],
                }

                out_doc["process"] = {"args": _doc["_source.process.args"]}
                out_doc["threat"] = {"software": {"config": extracted_config}}

                if _doc.get("_source.file"):
                    _file = {}
                    if _doc.get("_source.file.hash"):
                        _file["hash"] = _doc["_source.file.hash"]
                    if _doc.get("_source.file.name"):
                        _file["name"] = _doc["_source.file.name"]
                    if _doc.get("_source.file.size"):
                        _file["size"] = _doc["_source.file.size"]
                    if _file:
                        out_doc["file"] = _file

                if _doc.get("_source.rule"):
                    out_doc["rule"] = _doc["_source.rule"]

                # TODO Add "related" field.
                out_doc["tags"] = ["malware", extracted_config["family"]]
                yield out_doc

                break

    def run(self) -> None:
        super().run()
        self._setup_modules()

        for item in self.transform():
            self.outq.put(item)

        self.outq.put(POISON_PILL)
        logger.debug("Shutting down transform")
