import json
from logging import getLogger
from queue import Queue

import click
from malduck.extractor import ExtractManager, ExtractorModules
from malduck.procmem import ProcessMemory
from scalpl import Cut

from thread import BaseThread

logger = getLogger(__name__)


class MalduckTransform(BaseThread):
    def __init__(self, config: Cut, taskq: Queue, outq: Queue, **kwargs) -> None:
        super().__init__(**kwargs)

        self.config: Cut = config
        self.modules = None
        self.samples = None
        self.taskq = taskq
        self.outq = outq

        logger.debug(f"Parsed input config: {self.config}")

    def _setup_modules(self):
        # Set up the module paths.
        if self.config["modules"]:
            logger.info("Getting os path of malduck modules...")
            self.modules = (
                self.config["modules"]
                if self.config["modules"]
                else logger.error("Please specify Malduck module path.")
            )

    def echo_config(self, extract_manager):
        if extract_manager.config:
            for config in extract_manager.config:
                family = config["family"]
                message = (
                    f"[+] Ripped '{family}' configuration:"
                )
                click.echo(message, err=True)
                click.echo(json.dumps(config, indent=4, sort_keys=True))


    def run(self) -> None:
        self._setup_modules()

        while True:
            try:

                if self.taskq.empty():
                    # If the task queue is empty, stop
                    click.echo("Task queue empty, waiting...", err=True)
                    break

                else:
                    # Attempt to get data from the queue.
                    # .get() will block this thread's execution
                    # until data is available
                    malduck_bytes = self.taskq.get()

                    # Calls Malduck 'extract' command with bytes passed to q.
                    click.echo("Picking up task...")

                    extractor_modules = ExtractorModules(modules_path=self.modules)
                    extract_manager = ExtractManager(extractor_modules)

                    if not extract_manager.extractors:
                        logger.exception(
                            f"[!] No extractor modules found under '{self.modules}'!"
                        )

                    _ = extract_manager.push_procmem(
                        ProcessMemory(malduck_bytes), rip_binaries=True
                    )

                    self.echo_config(extract_manager)

                    if extract_manager.config:
                        for conf in extract_manager.config:
                            self.outq.put(json.dumps(conf))

            except Exception as err:
                logger.exception(err)

            if self.done:
                logger.info("Stopping as I'm told")
                break

# Local testing for initial debugging..
# if __name__ == "__main__":
#     in_to_extract: Queue = Queue()
#     extract_to_out: Queue = Queue()

#     in_to_extract.put(bytes.fromhex("68007400740070003a002f"))

#     md = MalduckTransform(Cut({"modules": "protections-onweek-malduck/elastic/malware_config_extractor/modules"}), in_to_extract, extract_to_out)

#     md.start()
