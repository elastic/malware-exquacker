import json
import logging
import os
import selectors
import traceback
from functools import partial, reduce
from queue import Queue
from typing import Dict

import click
import ecs_logging
from marshmallow import Schema
from ruamel.yaml import YAML
from scalpl import Cut

from elastic.malware_config_extractor.input import AlertSampleESInput
from elastic.malware_config_extractor.malduck_extractor import MalduckExtractor

from .config import MalwareExtractorConfigSchema, get_environ_config
from .input import AlertSampleESInput
from .output import ESOutput
from .transform import MalduckTransform
from .utils import dedot_keys, merge_dict

PACKAGE_NAME = "elastic.malware_config_extractor"
DEFAULT_CONFIG = "config.yml"
logging.basicConfig(level=logging.NOTSET)
logger = logging.getLogger(__name__)


def setup_logging(ctx, param, verbosity: int):

    if verbosity is None:
        verbosity = 0

    if verbosity > 3:
        verbosity = 3

    pkglogger = logging.getLogger(PACKAGE_NAME)
    rootlog = logging.getLogger()

    _level: str = {0: "WARNING", 1: "INFO", 2: "DEBUG", 3: "NOTSET"}[verbosity]
    pkglogger.setLevel(_level)
    logger.setLevel(_level)

    if os.environ.get("ECS_LOG", None) is not None:
        # Add an ECS formatter to the Handler
        handler = logging.StreamHandler()
        handler.setFormatter(ecs_logging.StdlibFormatter())
        rootlog.handlers = [handler]
    else:
        if verbosity > 2:
            FORMAT = "[%(asctime)s.%(msecs)03d][%(filename)20s:%(lineno)-4s][%(threadName)s][ %(funcName)20s() ][%(levelname)s] %(message)s"
        else:
            FORMAT = "[%(asctime)s.%(msecs)03d][%(levelname)s] %(message)s"

        logging.basicConfig(format=FORMAT, datefmt="%Y-%m-%dT%H:%M:%S", force=True)

    # Pull back 3rd party loggers
    eslog = logging.getLogger("elasticsearch")
    eslog.setLevel("WARN")

    urllog = logging.getLogger("urllib3")
    urllog.setLevel("WARN")


def configure(ctx, param, filename):
    logger.debug(f"Running configure() to process {filename}")
    schema: Schema = MalwareExtractorConfigSchema()

    yaml_reader = YAML(typ="safe")

    # Get defaults
    _cfg: Dict = schema.dump(schema.load({}))
    _yaml: Dict = {}
    try:
        with open(filename, mode="rt") as _fh:
            _yaml = dedot_keys(yaml_reader.load(_fh))
    except FileNotFoundError:
        pass

    _yaml = schema.dump(schema.load(_yaml))

    _env: Dict = get_environ_config()
    _env = schema.dump(schema.load(_env))

    # Merge all configs: env overides yaml overrides defaults
    reduce(partial(merge_dict, overwrite=True), [_cfg, _yaml, _env])

    logger.debug(f"result: {_cfg}")

    ctx.config = _cfg

    return _cfg


@click.command()
@click.option(
    "-v", count=True, is_eager=True, default=0, type=click.INT, callback=setup_logging
)
@click.option(
    "-c",
    "--config",
    type=click.Path(dir_okay=False),
    default=DEFAULT_CONFIG,
    callback=configure,
    is_eager=True,
    expose_value=False,
    help="Read options from the specified YAML file",
    show_default=True,
)
@click.option(
    "--daemon/--oneshot",
    default=False,
    is_flag=True,
    help="Detach and execute in the background or just run once",
    show_default=True,
)
@click.option(
    "--poll-interval",
    default=1440,
    type=click.IntRange(min=0, min_open=True),
    help="Duration in minutes between searches when --daemon is true",
    show_default=True,
)
@click.option(
    "--since",
    type=click.STRING,
    help="ISO datetime string or Elastic datemath for earliest event",
)
@click.option(
    "--before",
    type=click.STRING,
    help="ISO datetime string or Elastic datemath for latest event",
)
@click.version_option(package_name=PACKAGE_NAME)
@click.pass_context
def main(ctx, **kwargs):
    logger.debug(f"Got extra kwargs: {json.dumps(kwargs, sort_keys=True, indent=4)}")

    event_queue = Queue(maxsize=0)

    _cfg: Cut = Cut(ctx.config)
    in_to_extract: Queue = Queue()
    extract_to_out: Queue = Queue()

    es_input_thread = AlertSampleESInput(
        config=_cfg["input.elasticsearch"],
        outq=in_to_extract,
        background=kwargs.get("daemon", False),
        poll_interval=kwargs["poll_interval"],
        since=kwargs["since"],
        before=kwargs["before"],
        name="ESInput",
    )

    malduck_transform_thread = MalduckTransform(
        config=_cfg["malduck"],
        taskq=in_to_extract,
        outq=extract_to_out,
        name="MalduckTransform",
    )
    es_output_thread = ESOutput(
        config=_cfg["output.elasticsearch"], taskq=extract_to_out, name="ESOutput"
    )

    sel = selectors.DefaultSelector()
    sel.register(es_input_thread.done, selectors.EVENT_READ, es_input_thread)
    sel.register(
        malduck_transform_thread.done, selectors.EVENT_READ, malduck_transform_thread
    )
    sel.register(es_output_thread.done, selectors.EVENT_READ, es_output_thread)

    # start all the threads
    es_input_thread.start()
    malduck_transform_thread.start()
    es_output_thread.start()

    while True:
        if all(
            [es_input_thread.done, malduck_transform_thread.done, es_output_thread.done]
        ):
            break
        for ev, mask in sel.select():
            try:
                logger.info(f"Joining {ev.data.name}")
                ev.data.join()
                ev.data.done.clear()
            except BaseException as e:
                # halt the other threads
                logger.error(f"An uncaught error occured: {e}")
                logger.error(traceback.format_exc())
                es_input_thread.done.set()
                malduck_transform_thread.done.set()
                es_output_thread.done.set()

    try:
        # join all the threads
        es_input_thread.join()
        malduck_transform_thread.join()
        es_output_thread.join()
    except Exception:
        pass

    logger.info("All done.")


if __name__ == "__main__":
    main()
