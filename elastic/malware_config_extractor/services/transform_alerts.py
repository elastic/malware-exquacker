import base64
import sys
from typing import Any, Iterable
import zlib

from confluent_kafka import Consumer, Producer
from malduck.extractor import ExtractManager, ExtractorModules
from malduck.procmem import ProcessMemory
from scalpl import Cut

from elastic.malware_config_extractor import config, utils

logger = utils.default_logger(__name__)


class MalduckTransformer:
    def __init__(
        self,
        config: Cut,
    ) -> None:
        self.config: Cut = config
        self.modules = None
        self.samples = None
        self.extractor_modules: ExtractorModules | None = None
        self.extract_manager: ExtractManager | None = None

    def _setup_modules(self):
        # Set up the module paths.
        if self.config["modules"]:
            logger.info("Getting os path of malduck modules...")
            self.modules = (
                self.config["modules"]
                if self.config["modules"]
                else logger.error("Please specify Malduck module path.")
            )

        self.extractor_modules = ExtractorModules(modules_path=self.modules)

    def process_configs(self, extract_manager):
        if extract_manager.config:
            for config in extract_manager.config:
                logger.debug(config)
                family = config["family"]
                logger.info("[+] Ripped '%s' configuration:", family)
                logger.debug(config)
                yield config

    def transform(self, doc) -> Iterable[dict[str, Any]]:
        _doc = Cut(doc)
        _bytes_compressed = _doc["_source.process.Ext.memory_region.bytes_compressed"]
        logger.debug("Decompressing")
        _payload_bytes = zlib.decompress(base64.b64decode(_bytes_compressed))

        if self.extractor_modules:
            self.extract_manager = ExtractManager(self.extractor_modules)
        else:
            logger.error("extractor_modules not initialized! %s", self.extractor_modules)
            sys.exit(1)

        if not self.extract_manager.extractors:
            logger.exception("[!] No extractor modules found under '%s'!", self.modules)
        self.extract_manager.push_procmem(ProcessMemory(_payload_bytes), rip_binaries=True)

        for item in self.generate_output_doc(_doc, self.extract_manager):
            yield item

    def generate_output_doc(self, _doc, extract_manager) -> Iterable[dict[str, Any]]:
        if extract_manager.config:
            logger.debug("Generating output doc")
            for extracted_config in extract_manager.config:
                out_doc: dict[str, Any] = {}
                out_doc["@timestamp"] = _doc["_source.@timestamp"]
                out_doc["_id"] = _doc["id"]
                out_doc["agent"] = {"id": _doc["_source.agent.id"]}
                out_doc["event"] = {
                    "kind": "event",
                    "category": "malware",
                    "type": "info",
                }
                out_doc["event"]["xref"] = {  # type: ignore
                    "cluster_name": _doc["_cluster_info.cluster_name"],
                    "cluster_uuid": _doc["_cluster_info.cluster_uuid"],
                    "index": _doc["index"],
                    "id": _doc["id"],
                }

                if "rule" in extracted_config:
                    out_doc["rule"] = extracted_config["rule"]
                    del extracted_config["rule"]
                elif _doc.get("_source.rule"):
                    out_doc["rule"] = _doc["_source.rule"]

                out_doc["process"] = _doc["_source.process"]
                out_doc["threat"] = {"software": {"config": extracted_config}}

                if _doc.get("_source.file"):
                    _file = {}
                    if _doc.get("_source.file.hash"):
                        _file["hash"] = _doc["_source.file.hash"]
                    if _doc.get("_source.file.name"):
                        _file["name"] = _doc["_source.file.name"]
                    if _doc.get("_source.file.size"):
                        _file["size"] = _doc["_source.file.size"]
                    if _file:
                        out_doc["file"] = _file

                # TODO Add "related" field.
                out_doc["tags"] = ["malware", extracted_config["family"]]
                yield out_doc

                break


def main():
    # malduck_transformer = MalduckTransformer()
    # malduck_transformer._setup_modules()
    c = Consumer(
        {
            "bootstrap.servers": "kafka",
            "group.id": "malware-exquacker",
            "auto.offset.reset": "earliest",
        }
    )

    p = Producer(
        {
            "bootstrap.servers": "kafka",
        }
    )

    c.subscribe([config.QUACKABLE_ALERTS_TOPIC])

    while True:
        msg = c.poll(1.0)

        if msg is None:
            continue
        if msg.error():
            print("Consumer error: {}".format(msg.error()))
            continue

        # for record in malduck_transformer.transform(msg):
        p.poll(0)
        p.produce(
            topic=config.ENRICHED_ALERTS_TOPIC,
            key=msg.key(),
            value=msg.value(),
            callback=utils.delivery_report,
        )
        p.flush()


if __name__ == "__main__":
    main()
